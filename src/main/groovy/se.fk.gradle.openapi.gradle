import org.gradle.api.provider.Property
import org.gradle.api.provider.ListProperty
import org.gradle.api.provider.MapProperty

interface FKOpenApiPluginExtension {
	ListProperty<String> getImportApis()
	MapProperty<String, String> getImportMappings()
	/**
	 * The generator name to use, see https://openapi-generator.tech/docs/generators
	 */
	Property<String> getGeneratorName()
	MapProperty<String, String> getAdditionalProperties()
}

def extension = project.extensions.create("fkOpenApi", FKOpenApiPluginExtension)

extension.importApis.convention([])
extension.importMappings.convention([:])
extension.generatorName.convention("openapi-yaml")
extension.additionalProperties.convention([
	interfaceOnly: "true",
	skipDefaultInterface: "true",
	useBeanValidation: "true",
	performBeanValidation: "false",
	useTags: "true",
	serializableModel: "true",
	useSwaggerAnnotations: "false",
	dateLibrary: "java8",
	containerDefaultToNull: "true",
	useJakartaEe: "true"
])

/**
 * Implementation
 */
dependencies {
	compileOnly 'io.swagger.core.v3:swagger-annotations:2.2.38'
	compileOnly 'org.openapitools:jackson-databind-nullable:0.2.6'
	compileOnly 'org.springframework:spring-web:6.1.3'
	compileOnly 'org.springframework:spring-context:6.1.13'
	compileOnly "jakarta.platform:jakarta.jakartaee-api:9.0.0"
	compileOnly "javax.ws.rs:javax.ws.rs-api:2.1.1"
}

task prepareOpenapiYaml {
	doLast {
		extension.importApis.get().each { dependency ->
			def importedApi = configurations.detachedConfiguration(dependencies.create(dependency))
			copyResourceFromConfiguration(importedApi, dependency, "openapi.yaml")
		}

		def props = new Properties()
		props.load(new FileReader(file("$rootDir/gradle.properties")))
		def artifactVersion = props.get("version")

		def openApiFile = file("$rootDir/openapi.yaml")
		if (!openApiFile.exists()) {
			throw new RuntimeException("There should be a openapi.yaml in the root of the repo.")
		}
		def openapiYaml = new org.yaml.snakeyaml.Yaml().load(openApiFile.text)
		def apiSpecVersion = openapiYaml.info.version
		def apiSpecTitle = openapiYaml.info.title
		if (apiSpecVersion != artifactVersion) {
			logger.info("Setting openapi.yaml version to: \"" + artifactVersion + "\" from gradle.properties, was before \"" + apiSpecVersion + "\"")
			openapiYaml.info.version = artifactVersion
			apiSpecVersion = artifactVersion
		}

		logger.info("Paths:")
		openapiYaml.paths.each { path, config -> logger.info(path) }
	}
}

def props = new Properties()
props.load(new FileReader(file("$rootDir/gradle.properties")))
def artifactGroup = props.get("group")
def artifactVersion = props.get("version")

task generateJarApi(type: org.openapitools.generator.gradle.plugin.tasks.GenerateTask) {
	generatorName = extension.generatorName
	apiPackage = providers.provider({
		def generatorSafeName = extension.generatorName.get().replaceAll("[^a-zA-Z]","")
		return "${artifactGroup}.${generatorSafeName}.controllers.generatedsource"
	})
	modelPackage = providers.provider({
		def generatorSafeName = extension.generatorName.get().replaceAll("[^a-zA-Z]","")
		return "${artifactGroup}.${generatorSafeName}.controllers.generatedsource.model"
	})
	inputSpec = "$rootDir/openapi.yaml".toString()
	outputDir = "$buildDir/generated-source".toString()

	importMappings.set(extension.importMappings)

	additionalProperties = extension.additionalProperties
}

task generateFullJarApiGenerator(type: org.openapitools.generator.gradle.plugin.tasks.GenerateTask) {
	generatorName = "openapi-yaml"
	inputSpec = "$rootDir/openapi.yaml".toString()
	outputDir = "$buildDir/openapi-full-yaml".toString()
}
generateFullJarApiGenerator.dependsOn tasks.prepareOpenapiYaml

shouldGitIgnore("src/main/resources/openapi.yaml")
def resources = file("src/main/resources")
resources.mkdirs()
task copySpec(type: Copy) {
	from file("$buildDir/openapi-full-yaml/openapi/openapi.yaml")
	into file("src/main/resources")
}
copySpec.dependsOn generateFullJarApiGenerator
def artifactgroupstring = artifactGroup.replace(".", "/")
logger.info("artict string ${artifactgroupstring}")

tasks.named("processResources") {
	dependsOn("copySpec")
}
sourceSets.main.java.srcDirs += "$buildDir/generated-source/src/main/java"
sourceSets.main.java.srcDirs += "$buildDir/generated-source/src/gen/java"

generateJarApi.dependsOn tasks.prepareOpenapiYaml
generateJarApi.dependsOn tasks.copySpec
compileJava.dependsOn tasks.generateJarApi

def shouldGitIgnore(content) {
	def gitIgnoreFile = file("$rootDir/.gitignore")
	if (!gitIgnoreFile.exists()) {
		throw new RuntimeException("There should be a .gitignore in the root of the repo.")
	}
	def gitIgnoreContent = gitIgnoreFile.text
	if (!gitIgnoreContent.contains(content)) {
		throw new RuntimeException(content + " should be included in .gitignore.")
	}
}

def copyResourceToFile(String fromResource, String toFile, classloader = project.buildscript.classLoader) {
	logger.info("Copying " + fromResource + " to " + toFile)

	def resourceText = null

	// Try reading from classloader
	def resourceUri = classloader.getResource(fromResource)
	if (resourceUri != null) {
		logger.debug("uri " + resourceUri)
		resourceText = resourceUri.getText()
	} else {
		// Try reading from file system
		def fileInResources = file("src/main/resources/$fromResource")
		if (fileInResources.exists()) {
			resourceText = fileInResources.text
		}
	}

	// Throw exception if we couldn't read the file
	if (resourceText == null) {
		throw new RuntimeException("Could not find " + fromResource)
	}
	logger.debug("text " + resourceText)

	// Copy to toFile
	file(toFile).getParentFile().mkdirs()
	FileWriter fw = new FileWriter(toFile);
	BufferedWriter bw = new BufferedWriter(fw);
	bw.write(resourceText);
	bw.close();

	logger.debug("done")
}

def copyResourceFromConfiguration(configuration, String dependency, String source) {
	def dependencyParts = dependency.split(':')
	def dependencyGroup = dependencyParts[0]
	def dependencyName = dependencyParts[1]
	def dependencyVersion = dependencyParts[2]
	def target = "openapi-" + dependencyName + ".yaml"
	shouldGitIgnore(target)

	def found = []
	def foundUrl = configuration.files
			.find { file ->
				found.add(file)
				file.toURI().toURL().toString().contains(dependencyGroup + "/" + dependencyName + "/" + dependencyVersion)
			}
	if (foundUrl == null) {
		throw new RuntimeException("Could not find matching " + dependency + " among: " + found)
	}
	logger.info("Found " + dependency + " as " + foundUrl)
	ArrayList urls = new ArrayList()
	urls.add(foundUrl.toURI().toURL())
	def classLoader = new URLClassLoader(urls.toArray(new URL[0]));

	copyResourceToFile(source, target, classLoader)
}

def writeFile(content,filename) {
	def writer = new OutputStreamWriter(new FileOutputStream(file(filename)), "UTF-8");
	try {
		new org.yaml.snakeyaml.Yaml().dump(content, writer);
		writer.flush()
	} finally {
		writer.close()
	}
}

def isWindows() {
	return System.getProperty('os.name').toLowerCase(Locale.ROOT).contains('windows')
}